
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/xuqingfeng/mailman/util/boltStore.go (75.0%)</option>
				
				<option value="file1">github.com/xuqingfeng/mailman/util/util.go (62.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package util

import (
        "errors"
        "github.com/boltdb/bolt"
)

const (
        dbFileMode = 0600
)

var (
        KVBucketName       = []byte("kv")
        AccountBucketName  = []byte("account")
        ContactsBucketName = []byte("contacts")
        SmtpBucketName     = []byte("smtp")
        testBucketName     = []byte("test")
        KeyNotFoundErr     = errors.New("Key Not Found")
)

type BoltStore struct {
        conn *bolt.DB
        path string
}

func NewBoltStore(path string) (*BoltStore, error) <span class="cov8" title="1">{

        //handle, err := bolt.Open(path, dbFileMode, &amp;bolt.Options{Timeout: 1 * time.Second})
        handle, err := bolt.Open(path, dbFileMode, nil)
        if err != nil </span><span class="cov0" title="0">{
                FileLog.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">store := &amp;BoltStore{
                handle,
                path,
        }

        if err := store.initialize(); err != nil </span><span class="cov0" title="0">{
                FileLog.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return store, nil</span>
}

func (b *BoltStore) initialize() error <span class="cov8" title="1">{

        tx, err := b.conn.Begin(true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // ?
        <span class="cov8" title="1">defer tx.Rollback()

        // create all buckets
        if _, err = tx.CreateBucketIfNotExists(KVBucketName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.CreateBucketIfNotExists(AccountBucketName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.CreateBucketIfNotExists(ContactsBucketName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.CreateBucketIfNotExists(SmtpBucketName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.CreateBucketIfNotExists(testBucketName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// defer close
func (b *BoltStore) Close() error <span class="cov8" title="1">{

        return b.conn.Close()
}</span>

func (b *BoltStore) Set(k, v, bucketName []byte) error <span class="cov8" title="1">{

        tx, err := b.conn.Begin(true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        bucket := tx.Bucket(bucketName)
        if err := bucket.Put(k, v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (b *BoltStore) Get(k, bucketName []byte) ([]byte, error) <span class="cov8" title="1">{

        tx, err := b.conn.Begin(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        bucket := tx.Bucket(bucketName)
        // The returned value is only valid for the life of the transaction.
        val := bucket.Get(k)

        if val == nil </span><span class="cov8" title="1">{
                return nil, KeyNotFoundErr
        }</span>

        <span class="cov8" title="1">return append([]byte{}, val...), nil</span>
}

func (b *BoltStore) Delete(k, bucketName []byte) error <span class="cov8" title="1">{

        tx, err := b.conn.Begin(true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        bucket := tx.Bucket(bucketName)

        err = bucket.Delete(k)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // commit needed !
        <span class="cov8" title="1">return tx.Commit()</span>
}

func (b *BoltStore) DeleteBucket(bucketName []byte) error <span class="cov8" title="1">{

        tx, err := b.conn.Begin(true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        tx.DeleteBucket(bucketName)

        return tx.Commit()</span>
}

// range map
// the iteration order is not specified and is not guaranteed to be the same from one iteration to the next.
// https://blog.golang.org/go-maps-in-action
func (b *BoltStore) GetRange(bucketName []byte) (map[string]string, []string, error) <span class="cov8" title="1">{

        tx, err := b.conn.Begin(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        ret := make(map[string]string)
        var order []string
        curs := tx.Bucket(bucketName).Cursor()
        // reverse
        for k, v := curs.First(); k != nil; k, v = curs.Next() </span><span class="cov8" title="1">{
                ret[string(k)] = string(v)
                order = append(order, string(k))
                //FileLog.Warn("k: " + string(k) + " " + "v: " + string(v))
        }</span>
        <span class="cov8" title="1">return ret, order, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package util

import (
        "errors"
        "github.com/Sirupsen/logrus"
        "os"
        "os/user"
)

const (
        configMode       = 0755
        dbName           = "mailman.db"
        LogName          = "mailman.log"
        DefaultSMTPPort  = 25
        MailBodyKey      = "YTua0G1ViXGg9fxvrtwVRNfKD"
        MailTemplatePath = "./web/mail-template"
        MailTemplateType = "responsive"
)

var (
        FileLog    = logrus.New()
        ConfigPath = map[string]string{
                "dbPath":  "/.mailman/db",
                "logPath": "/.mailman/log",
                "tmpPath": "/.mailman/tmp",
        }
        DBPath string
        DefaultLang = "en"
        DefaultSMTPServer = map[string]string{
                "@qq.com":      "smtp.qq.com",
                "@hotmail.com": "smtp.live.com",
                "@outlook.com": "smtp.live.com",
                "@gmail.com":   "smtp.gmail.com",
        }
        SMTPServerNotFoundErr = errors.New("SMTP Server Not Found")
)

func init() <span class="cov8" title="1">{

        homeDir, _ := GetHomeDir()
        CreateConfigDir()
        logFile, err := os.OpenFile(homeDir+ConfigPath["logPath"]+"/"+LogName, os.O_WRONLY|os.O_CREATE, configMode)
        if err != nil </span><span class="cov0" title="0">{
                // mailman.log not exist
                FileLog.Fatal(err.Error())
                //log.Fatal(err)
        }</span>
        <span class="cov8" title="1">FileLog.Out = logFile
        FileLog.Formatter = &amp;logrus.TextFormatter{DisableColors: true}
        DBPath = homeDir + ConfigPath["dbPath"] + "/" + dbName</span>
}

type Msg struct {
        Success bool        `json:"success"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,emitempty"`
}

func GetHomeDir() (string, error) <span class="cov8" title="1">{

        user, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                FileLog.Fatal(err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">return user.HomeDir, nil</span>
}

func CreateConfigDir() error <span class="cov8" title="1">{

        homeDir, _ := GetHomeDir()
        for _, path := range ConfigPath </span><span class="cov8" title="1">{
                var p = homeDir + path
                if _, err := os.Stat(p); err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                if err := os.MkdirAll(p, configMode); err != nil </span><span class="cov0" title="0">{
                                        FileLog.Fatal(err.Error())
                                        return err
                                }</span>
                        }<span class="cov0" title="0"> else {
                                FileLog.Fatal(err.Error())
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
